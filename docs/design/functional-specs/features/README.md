# Introducción
El ecosistema de herramientas para el lenguaje C++ es uno maduro, y con gran variedad. Sin embargo, en el área de los Sistemas de Construcción (Build Systems), es uno que palidece con respecto a las opciones que podemos encontrar en otros ecosistemas de lenguajes, como Gradle o Node Package Manager.
Los principales problemas que surgen a partir de los build system tradicionales son:
- Bajo nivel de abstracción: Proveen una poca capacidad de abstracción sobre el proceso de compilación. Esto provoca que el desarrollador tenga que invertir grandes cantidades de tiempo para corregir los archivos de definición.
- Poca o nula gestión de paquetes: Esto provoca que el desarrollador tenga que descargar, compilar e instalar paquetes externos de librerías de forma separada.
- Poco soporte para múltiples compiladores y targets: En CMake, el desarrollador debe configurar (llámese, ubicar dependencias externas, establecer opciones de compilación, etc) varias veces la compilación de un mismo paquete cada vez que quiere y/o debe usar un compilador distinto, o el mismo compilador con diferentes configuraciones.
Es por esto que nace “borc”, una alternativa que toma inspiración de las mejores características de los gestores de compilación de otras plataformas para remediar la situación antes descrita.

# Problemas de otras herramientas de construcción a Resolver
Los problemas que se encuentran en estos build systems son:
1. Los DSL’s para definir los modulos a compilar, son por definición turing-complete: Esto, si bien permite una gran flexibilidad, en la práctica conduce a complejos archivos para definir proyectos no-triviales.
2. Gestión de las dependencias: CMake tiene un sistema de librerias/paquetes, que solo está definido para referenciar dependencias locales. Los proyectos deben definir muchas veces procesos manuales para “automatizar” en parte este problema. Boost, por ejemplo, debe ser compilado y descargado de forma manual.
3. Builds manuales: Para agregar un nuevo compilador / tipo de construcción, en CMake, se debe reproducir el proceso de configuración desde 0, definiendo manualmente los paths hacia las dependencias externas. Peor aún si un proyecto está definiendo multiples arquitecturas y compilación.
4. Pipelines personalizados de compilación: Algunos proyectos (como videojuegos, o interfaces gráficas como Qt), requieren pipelines de compilación personalizados para compilar archivos fuente que no corresponden a los estándares de C++. Estos frameworks proveen compiladores adicionales para que se puedan conectar al pipeline de compilación. Sin embargo, para crear estos complementos, es necesario introducirse en la arcana definición para crear reglas de compilación.
5. Dificultad/manualidad durante el proceso de desarrollo de los componentes: Durante los procesos iterativos de desarrollo, se van creando diversos módulos que, posteriormente, es necesario refactorizar código existente en nuevos módulos con funcionalidades más refinadas. Esto implica un cierto esfuerzo de trabajo en crear y mantener las reglas de definición de los componentes cuando podría ser automatizado. Lo mismo aplica para crear proyectos desde 0: Es necesario crear la estructura de los proyectos desde 0 cuando podría ser generada automáticamente en base ciertos parámetros base que ingresa el usuario (de forma similar a como lo hace el tooling de Angular)
6. Interactividad en techstacks cross-lenguaje: Crear proyectos cross-lenguaje se torna complicado cuando el sistema de construcción base no entiende su lenguaje primario, debiendo crear hacks y forzando la compilació.
7. Incapacidad de ejecutar componentes que dependen de bibliotecas dinamicas: En CMake, es muy engorroso ejecutar componentes que dependen de librerias dinamicas dentro del mismo proyecto, por lo que es necesario realizar un proceso manual con las variables de entorno PATH para lograrlo.
8. Integración con sistemas de construcción pre-existentes: CMake es el estándar defacto para las herramientas de construcción de aplicaciones C++ en la actualidad.

